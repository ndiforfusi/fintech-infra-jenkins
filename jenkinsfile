pipeline {
  agent any

  /* ---------- Parameters ---------- */
  parameters {
    choice(name: 'ENVIRONMENT', choices: ['dev', 'qa', 'uat', 'prod'], description: 'Deployment Environment')
    string(name: 'REGION', defaultValue: 'us-west-2', description: 'AWS Region')
    choice(name: 'ACTION', choices: ['apply', 'destroy'], description: 'Terraform action')

    // IMPORTANT: This must be the *deploy* role (e.g., TerraformDeployRole), not your instance profile/base role.
    // You may leave this blank and set TERRAFORM_DEPLOY_ROLE_ARN as a global env var in Jenkins System Settings.
    string(
      name: 'ASSUME_ROLE_ARN',
      defaultValue: 'arn:aws:iam::327019199684:role/TerraformDeployRole',
      description: 'STS role ARN to assume for Terraform (deploy role, not base role)'
    )
  }

  /* ---------- Global env ---------- */
  environment {
    TF_ENV            = "${params.ENVIRONMENT}"
    AWS_REGION        = "${params.REGION}"
    TF_DIR            = "${params.ENVIRONMENT}"  // folder per env (dev/qa/uat/prod)
    TF_INPUT          = 'false'
    TF_IN_AUTOMATION  = 'true'
    // If you configure a Jenkins tool named "terraform-1.13.4":
    // PATH = "${tool 'terraform-1.13.4'}/bin:${env.PATH}"
  }

  /* ---------- Options ---------- */
  options {
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    timeout(time: 60, unit: 'MINUTES')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        script {
          echo "Branch: ${env.BRANCH_NAME ?: 'N/A'} | PR: ${env.CHANGE_ID ?: 'no'}"
        }
      }
    }

    stage('Verify Working Directory') {
      steps {
        sh """
          echo "Working in ./${TF_DIR}"
          ls -la "./${TF_DIR}"
        """
      }
    }

    stage('Terraform Setup') {
      steps {
        sh 'terraform version || true'
      }
    }

    stage('WhoAmI (before assume)') {
      steps {
        sh 'aws sts get-caller-identity || true'
      }
    }

    stage('Terraform Fmt / Validate') {
      steps {
        sh """
          cd "${TF_DIR}"
          terraform fmt -check -recursive
          terraform init -upgrade -backend-config="key=${TF_ENV}/terraform.tfstate"
          terraform validate
        """
      }
    }

    stage('Terraform Plan') {
      steps {
        script {
          def roleArn = chooseRoleArn(params.ASSUME_ROLE_ARN)
          withAssumedRole(AWS_REGION, roleArn) {
            sh """
              cd "${TF_DIR}"
              terraform plan -lock=false -out plan.tfplan
              terraform show -no-color plan.tfplan > plan.txt
            """
          }
        }
        archiveArtifacts artifacts: "${TF_DIR}/plan.tfplan, ${TF_DIR}/plan.txt", fingerprint: true
        stash name: 'tf-plan-bundle', includes: "${TF_DIR}/plan.tfplan, ${TF_DIR}/plan.txt"
      }
    }

    stage('Approval Gate') {
      when {
        anyOf {
          branch 'release'
          allOf { not { changeRequest() }; expression { params.ACTION == 'apply' } }
        }
      }
      steps {
        script {
          timeout(time: 30, unit: 'MINUTES') {
            input message: "Approve ${params.ACTION.toUpperCase()} for ENV=${params.ENVIRONMENT}, REGION=${params.REGION} on branch ${env.BRANCH_NAME ?: 'N/A'}?",
                  ok: 'Approve'
          }
        }
      }
    }

    stage('Terraform Apply') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        script {
          def roleArn = chooseRoleArn(params.ASSUME_ROLE_ARN)
          unstash 'tf-plan-bundle'
          withAssumedRole(AWS_REGION, roleArn) {
            sh """
              cd "${TF_DIR}"
              terraform init -backend-config="key=${TF_ENV}/terraform.tfstate"
              terraform apply -auto-approve -lock=false plan.tfplan
            """
          }
        }
      }
    }

    stage('Terraform Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        script {
          def roleArn = chooseRoleArn(params.ASSUME_ROLE_ARN)
          withAssumedRole(AWS_REGION, roleArn) {
            sh """
              cd "${TF_DIR}"
              terraform init -backend-config="key=${TF_ENV}/terraform.tfstate"
              terraform destroy -auto-approve -lock=false
            """
          }
        }
      }
    }

    stage('WhoAmI (after assume)') {
      steps {
        script {
          def roleArn = chooseRoleArn(params.ASSUME_ROLE_ARN)
          withAssumedRole(AWS_REGION, roleArn) {
            sh 'aws sts get-caller-identity'
          }
        }
      }
    }
  }

  post {
    success {
      echo "✅ Success: ${params.ACTION} for ${params.ENVIRONMENT} in ${params.REGION}"
    }
    failure {
      echo "❌ Failed: ${params.ACTION} for ${params.ENVIRONMENT} in ${params.REGION}"
    }
    always {
      cleanWs(deleteDirs: true, notFailBuild: true)
    }
  }
}

/* =======================================================================
   Helpers: force AssumeRole (no static fallback) + role selection
   ======================================================================= */

def chooseRoleArn(String paramArn) {
  def arn = (paramArn?.trim()) ? paramArn.trim() : (env.TERRAFORM_DEPLOY_ROLE_ARN ?: '').trim()
  if (!arn) {
    error """No deploy role ARN provided.
- Set the pipeline parameter ASSUME_ROLE_ARN, or
- Configure a global env var TERRAFORM_DEPLOY_ROLE_ARN in Jenkins System Settings."""
  }
  echo "Using deploy role ARN: ${arn}"
  return arn
}

def withAssumedRole(String region, String roleArn, Closure body) {
  // Requires the AWS Steps plugin
  withAWS(region: region, role: roleArn, duration: 3600) { body() }
}
